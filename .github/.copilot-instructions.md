下面是一份可直接放在專案根目錄的 **`.copilot.instructions.md`** 範例。內容以你指定的技術棧（.NET 9 / C#、Hexagonal Architecture、四專案切分）為核心，提供給 Copilot 作為「長期上下文與規範」。你可以照抄後再依實際需求微調。

---

# .copilot.instructions.md

這份文件用來告知 GitHub Copilot：在此程式庫中產生程式碼與回答技術問題時，必須遵循下列規範與偏好。專案採用 **.NET 9+ / C#** 與 **Hexagonal Architecture（Ports & Adapters）**，並切分為四個專案：

* **Application**（應用層 / Use Cases）
* **Domain**（網域層 / 企業邏輯）
* **Infrastructure**（基礎設施層 / Adapters）
* **Web**（介面層 / API/UI；Composition Root）

## 1) 架構原則（Hexagonal / Clean）

* **方向性（依賴流向）**

  * `Web → Application → Domain`
  * `Infrastructure → Domain`（實作介面），在 **組態注入** 於 `Web` 專案完成繫結。
  * **不得**由 `Domain` 參考 `Application` 或 `Infrastructure`。
  * **不得**由 `Application` 參考 `Infrastructure`（只能依賴介面 Port）。

* **分層職責**

  * **Domain**：Entities、Value Objects、Domain Events、Domain Services、核心商業規則（高凝聚、無基礎設施相依）。
  * **Application**：Use Cases（指令/查詢）、服務介面（Ports）、DTO/Contracts、交易邊界、工作單元、跨切面協調（無 UI/資料庫細節）。
  * **Infrastructure**：Repositories、外部服務 Adapter、ORM（EF Core）與其它 I/O 實作，實踐 `Application`/`Domain` 定義的介面。
  * **Web**：API/Controllers/Minimal API、輸入驗證、授權、例外轉換、DI 組態、Observability（Log/Tracing/Metrics）。

* **Ports & Adapters**

  * 在 `Application` 定義 **Ports（介面）**：例如 `ICustomerRepository`, `IPaymentGateway`。
  * 在 `Infrastructure` 提供 **Adapters（實作）**：例如 `EfCustomerRepository`, `StripePaymentGateway`。
  * 在 `Web` 的 `Program.cs` / `Startup` 完成 DI 註冊。

## 2) 專案與命名規範

* **專案名稱**

  * `Company.Product.Domain`
  * `Company.Product.Application`
  * `Company.Product.Infrastructure`
  * `Company.Product.Web`

* **命名**

  * 介面以 **名詞或職責** 為名（避免 `IManager` / `IHelper` 這種籠統名稱）。
  * Command/Query 後綴：`CreateOrderCommand`, `GetOrderByIdQuery`。
  * Handler 後綴：`CreateOrderCommandHandler`, `GetOrderByIdQueryHandler`。
  * Repository 後綴：`CustomerRepository`（介面可為 `ICustomerRepository`）。

* **命名空間對應資料夾**

  * `Domain/Entities`, `Domain/ValueObjects`, `Domain/Events`, `Domain/Services`
  * `Application/Abstractions`（Ports & Contracts）, `Application/UseCases/Orders/Create`, `Application/Common`
  * `Infrastructure/Persistence`, `Infrastructure/Adapters`, `Infrastructure/Configurations`
  * `Web/Controllers` 或 `Web/Endpoints`, `Web/Filters`, `Web/Configurations`

## 3) 程式碼風格與語言功能（C# / .NET 9+）

* **啟用 Nullable**（`<Nullable>enable</Nullable>`），使用 `required` 成員與 **readonly struct**/record 適處使用。
* 一律以 **非同步** 為預設：方法使用 `async/await`、支援 `CancellationToken`。
* **例外處理**：在 `Web` 層集中處理（Exception Middleware/Filter），將網域錯誤轉為合適的 HTTP 狀態碼與問題詳情（RFC 7807）。
* **驗證**：`Web` 層使用 FluentValidation 或 DataAnnotations 做輸入驗證；`Domain` 以不變式與建構方法保證有效狀態。
* **記錄與追蹤**：使用 `ILogger<T>` 與 OpenTelemetry（如適用）；禁止在 `Domain` 直接寫 Log。
* **設定**：使用 `IOptions<T>` 綁定設定；嚴禁在 `Domain` 直接讀取設定檔。
* **時間 / ID**：抽象時間（`IClock`）與 ID 產生器（`IIdGenerator`）為 Ports，於 `Infrastructure` 實作，便於測試。
* **集合返回**：優先回傳 `IReadOnlyList<T>` / `IAsyncEnumerable<T>`；避免洩漏可變集合。

## 4) Use Case（Application 層）模式

* 採 **CQRS**：Command（改變狀態）、Query（讀取），分別定義資料契約與處理器。
* Use Case 只組織 **Domain** 規則與資源協調，不含 UI/ORM 細節。
* 需要交易邊界時，使用 `IUnitOfWork` 或 EF Core Transaction，由 `Infrastructure` 實作、`Application` 注入。

**範例：Command 與 Handler（Application）**

```csharp
// Application/UseCases/Orders/Create/CreateOrderCommand.cs
public sealed record CreateOrderCommand(Guid CustomerId, IReadOnlyList<OrderLineDto> Lines) : ICommand<Guid>;

// Application/UseCases/Orders/Create/CreateOrderCommandHandler.cs
public sealed class CreateOrderCommandHandler : ICommandHandler<CreateOrderCommand, Guid>
{
    private readonly ICustomerRepository _customers;
    private readonly IOrderRepository _orders;
    private readonly IUnitOfWork _uow;

    public CreateOrderCommandHandler(ICustomerRepository customers, IOrderRepository orders, IUnitOfWork uow)
        => (_customers, _orders, _uow) = (customers, orders, uow);

    public async Task<Guid> Handle(CreateOrderCommand cmd, CancellationToken ct)
    {
        var customer = await _customers.GetByIdAsync(cmd.CustomerId, ct)
                      ?? throw new CustomerNotFoundException(cmd.CustomerId);

        var order = Order.Create(customer.Id, cmd.Lines.Select(l => new OrderLine(l.Sku, l.Qty, l.Price)));

        await _orders.AddAsync(order, ct);
        await _uow.SaveChangesAsync(ct);
        return order.Id;
    }
}
```

## 5) Domain 層指引

* **只有**商業邏輯：Entity、ValueObject、Domain Event、Domain Service。
* **禁止**任何 I/O、EF Core 相依、框架層型別（除了基礎 BCL）。
* 使用 **不變式**、**工廠/靜態建構** 保持狀態正確；以 **ValueObject** 表達語義（如 `Money`, `Email`）。

**範例：Entity 與 Value Object（Domain）**

```csharp
public sealed class Order : Entity<Guid>
{
    private readonly List<OrderLine> _lines = new();

    private Order(Guid id, Guid customerId) : base(id)
    {
        CustomerId = customerId;
        Status = OrderStatus.Draft;
    }

    public Guid CustomerId { get; }
    public OrderStatus Status { get; private set; }
    public IReadOnlyList<OrderLine> Lines => _lines;

    public static Order Create(Guid customerId, IEnumerable<OrderLine> lines)
    {
        var order = new Order(Guid.NewGuid(), customerId);
        foreach (var l in lines) order.AddLine(l);
        order.Raise(new OrderCreated(order.Id, customerId));
        return order;
    }

    public void AddLine(OrderLine line)
    {
        if (Status != OrderStatus.Draft) throw new DomainException("Cannot add lines once submitted.");
        _lines.Add(line);
    }
}

public sealed record OrderLine(string Sku, int Quantity, decimal UnitPrice);
```

## 6) Infrastructure 層指引

* 在此實作 **Repositories、ORM 映射、外部服務 Adapter、檔案/快取/訊息佇列** 等。
* EF Core：**嚴禁**將 `DbContext` 洩漏至 `Application`/`Domain`；在這層進行 Mapping（可用 EF Core Configuration）。
* 對外依賴以 **介面** 封裝，於 `Web` 註冊 DI。

**範例：Repository 實作（Infrastructure）**

```csharp
public sealed class EfOrderRepository(AppDbContext db) : IOrderRepository
{
    public Task<Order?> GetByIdAsync(Guid id, CancellationToken ct)
        => db.Orders
             .Include(o => o.Lines)
             .FirstOrDefaultAsync(o => o.Id == id, ct);

    public async Task AddAsync(Order order, CancellationToken ct)
        => await db.Orders.AddAsync(order, ct);
}
```

## 7) Web 層（API/UI）指引

* 可用 **Minimal API** 或 **Controllers**，需提供：

  * **模型驗證**（FluentValidation）
  * **API 版本化**與 OpenAPI（Swagger）
  * **例外 → 問題詳情** 的轉換（RFC 7807）
  * **DI 組態**：在這裡將 Ports 綁到 Infrastructure Adapters

**範例：DI 組態（Web/Program.cs）**

```csharp
builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(cfg.ConnectionString));
builder.Services.AddScoped<IOrderRepository, EfOrderRepository>();
builder.Services.AddScoped<ICustomerRepository, EfCustomerRepository>();
builder.Services.AddScoped<IUnitOfWork, EfUnitOfWork>();

builder.Services.AddValidatorsFromAssembly(typeof(CreateOrderCommand).Assembly);
builder.Services.AddEndpointsApiExplorer().AddSwaggerGen();
```

## 8) 測試策略

* **Domain**：純單元測試（無 I/O），聚焦商業規則與不變式。
* **Application**：Use Case 層以替身（mock/fake）測試 Ports；重要流程可加上整合測試。
* **Infrastructure**：資料庫整合測試（Testcontainers / 本地 SQL），外部服務以 wire-mock/stub。
* **Web**：端對端（E2E）或 API 整合測試（`WebApplicationFactory`）。

## 9) Pull Request 與 Commit

* Commit 格式（建議）：`feat(domain): add Order aggregate creation rules`
* PR 需包含：動機、變更摘要、風險/相容性、測試覆蓋、截圖（若前端）。

## 10) Copilot 產碼偏好（請嚴格遵守）

* 產碼時務必：

  1. **依分層放檔案**，正確命名空間。
  2. 預設加入 `CancellationToken` 與 `async` 版本方法。
  3. 不在 `Domain` 引入 EF/Log/HTTP 等框架相依。
  4. 於 `Application` 只依賴 **Ports**；於 `Infrastructure` 才存取 I/O。
  5. 提供必要的單元測試範例（xUnit + FluentAssertions）。
  6. 產生 API 時，同步產生 Swagger 註解與驗證規則。

---

### 附錄 A：最小可行資料夾結構（提議）

```
src/
  Company.RentalCar.Domain/
    Entities/
    ValueObjects/
    Events/
    Services/
    Exceptions/
  Company.RentalCar.Application/
    Abstractions/       // Ports、Contracts、Common
    UseCases/
      Orders/
        Create/
          CreateOrderCommand.cs
          CreateOrderCommandHandler.cs
    Common/
  Company.RentalCar.Infrastructure/
    Persistence/
      AppDbContext.cs
      Configurations/
    Adapters/
    Repositories/
  Company.RentalCar.Web/
    Program.cs
    Controllers/ or Endpoints/
    Filters/
    Configurations/
tests/
  Company.RentalCar.Domain.Tests/
  Company.RentalCar.Application.Tests/
  Company.RentalCar.Infrastructure.Tests/
  Company.RentalCar.Web.Tests/
```

---

> **給 Copilot 的摘要**：本庫使用 .NET 9+ / C# 與 Hexagonal 架構。四層分工明確，`Web` 做組態與 API、`Application` 做 Use Case 與 Ports、`Domain` 放純商業邏輯、`Infrastructure` 實作 Adapters。請依此分層產碼、遵守相依方向、預設 async/可測試、並補齊 DI 與驗證/例外處理。

---
